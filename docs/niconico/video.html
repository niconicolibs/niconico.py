<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>niconico.video API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="icon" href="https://avatars.githubusercontent.com/u/113749892?s=64">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>niconico.video</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># niconico.py - Video

from __future__ import annotations

from typing import TYPE_CHECKING, Callable, Iterator, Union, Optional, Any

from threading import Thread, Event
from time import time, sleep

from bs4 import BeautifulSoup
from json import loads

from .base import DictFromAttribute, BaseClient
from .exceptions import ExtractFailed
from .enums import VideoDownloadMode
from .utils import parse_link

from .objects.video import Comment, EasyComment, Tag, VideoOwner, Video as AbcVideo, MyList as AbcMyList
from .objects.comment import Comments, MovieChat

if TYPE_CHECKING:
    from .niconico import Response


__all__ = (&#34;HEADERS&#34;, &#34;Video&#34;, &#34;Client&#34;)
BASES = {
    &#34;heartbeat&#34;: &#34;https://api.dmc.nico/api/sessions&#34;
}
HEADERS = {
    &#34;normal&#34;: {
        &#39;Connection&#39;: &#39;keep-alive&#39;,
        &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62&#39;,
        &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;,
        &#39;Sec-Fetch-Site&#39;: &#39;none&#39;,
        &#39;Sec-Fetch-Mode&#39;: &#39;navigate&#39;,
        &#39;Sec-Fetch-User&#39;: &#39;?1&#39;,
        &#39;Sec-Fetch-Dest&#39;: &#39;document&#39;,
        &#39;sec-ch-ua&#39;: &#39;&#34; Not A;Brand&#34;;v=&#34;99&#34;, &#34;Chromium&#34;;v=&#34;96&#34;, &#34;Microsoft Edge&#34;;v=&#34;96&#34;&#39;,
        &#39;sec-ch-ua-mobile&#39;: &#39;?0&#39;,
        &#39;sec-ch-ua-platform&#39;: &#39;&#34;macOS&#34;&#39;,
        &#39;Accept-Language&#39;: &#39;ja,en;q=0.9,en-GB;q=0.8,en-US;q=0.7&#39;,
    },
    &#34;mylist&#34;: {
        &#39;Accept&#39;: &#39;*/*&#39;,
        &#39;Accept-Language&#39;: &#39;ja&#39;,
        &#39;Accept-Encoding&#39;: &#39;gzip, deflate, br&#39;,
        &#39;Host&#39;: &#39;nvapi.nicovideo.jp&#39;,
        &#39;Origin&#39;: &#39;https://www.nicovideo.jp&#39;,
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15&#39;,
        &#39;Connection&#39;: &#39;keep-alive&#39;,
        &#39;Referer&#39;: &#39;https://www.nicovideo.jp/&#39;,
        &#39;X-Frontend-Id&#39;: &#39;6&#39;,
        &#39;X-Niconico-Language&#39;: &#39;ja-jp&#39;,
        &#39;X-Frontend-Version&#39;: &#39;0&#39;,
    },
    &#34;heartbeat&#34;: {
        &#34;Host&#34;: &#34;api.dmc.nico&#34;,
        &#34;Connection&#34;: &#34;keep-alive&#34;,
        &#34;sec-ch-ua&#34;: &#39;&#34;Microsoft Edge&#34;;v=&#34;93&#34;, &#34; Not;A Brand&#34;;v=&#34;99&#34;, &#34;Chromium&#34;;v=&#34;93&#34;&#39;,
        &#34;Accept&#34;: &#34;application/json&#34;,
        &#34;Content-Type&#34;: &#34;application/json&#34;,
        &#34;sec-ch-ua-mobile&#34;: &#34;?0&#34;,
        &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38&#34;,
        &#34;sec-ch-ua-platform&#34;: &#34;Windows&#34;,
        &#34;Origin&#34;: &#34;https://www.nicovideo.jp&#34;,
        &#34;Sec-Fetch-Site&#34;: &#34;cross-site&#34;,
        &#34;Sec-Fetch-Mode&#34;: &#34;cors&#34;,
        &#34;Sec-Fetch-Dest&#34;: &#34;empty&#34;,
        &#34;Referer&#34;: &#34;https://www.nicovideo.jp/&#34;,
        &#34;Accept-Encoding&#34;: &#34;gzip, deflate, br&#34;,
        &#34;Accept-Language&#34;: &#34;ja,en;q=0.9,en-GB;q=0.8,en-US;q=0.7&#34;
    },
    &#34;heartbeat_first&#34;: {
        &#34;Host&#34;: &#34;api.dmc.nico&#34;,
        &#34;Connection&#34;: &#34;keep-alive&#34;,
        &#34;Accept&#34;: &#34;*/*&#34;,
        &#34;Access-Control-Request-Method&#34;: &#34;POST&#34;,
        &#34;Access-Control-Request-Headers&#34;: &#34;content-type&#34;,
        &#34;Origin&#34;: &#34;https://www.nicovideo.jp&#34;,
        &#34;User-Agent&#34;: &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38&#34;,
        &#34;Sec-Fetch-Mode&#34;: &#34;cors&#34;,
        &#34;Sec-Fetch-Site&#34;: &#34;cross-site&#34;,
        &#34;Sec-Fetch-Dest&#34;: &#34;empty&#34;,
        &#34;Referer&#34;: &#34;https://www.nicovideo.jp/&#34;,
        &#34;Accept-Encoding&#34;: &#34;gzip, deflate, br&#34;,
        &#34;Accept-Language&#34;: &#34;ja,en;q=0.9,en-GB;q=0.8,en-US;q=0.7&#34;
    }
}
&#34;リクエストに使用されるヘッダーが入っている定数です。&#34;


class Video(DictFromAttribute):
    &#34;&#34;&#34;ニコニコ動画のデータを含めるクラスです。
    動画をダウンロードすることができます。
    普通はこのクラスをインスタンスは :meth:`niconico.video.Client.get_video` を使って作ります。

    Parameters
    ----------
    client : Client
        動画クライアントクラスのインスタンスです。
    url : str
        取得する動画のURLです。
    data : dict
        動画の辞書形式のデータです。  
        属性からこのデータにアクセスすることができます。&#34;&#34;&#34;

    __dfa_class__ = DictFromAttribute

    easyComment: EasyComment
    &#34;簡易コメントデータです。&#34;
    tag: Tag
    &#34;動画についているタグです。&#34;
    video: AbcVideo
    &#34;動画のデータです。&#34;
    owner: Optional[VideoOwner]
    &#34;動画の投稿者です。&#34;
    thread: Optional[Thread] = None
    &#34;ハートビートを動かすスレッドです。&#34;
    url: str
    &#34;動画のURLです。&#34;
    client: Client
    &#34;動画取得用のクライアントのインスタンスです。&#34;
    comment: Comment
    &#34;コメントのデータです。&#34;

    def __init__(self, client: Client, url: str, data: dict):
        self.client, self.url, self.__data__ = client, url, data
        self._heartbeat_running = Event()
        self._download_log: Optional[Callable[[Any], None]] = None
        super().__init__(self.__data__, self)

    def __str__(self) -&gt; str:
        return f&#34;&lt;Video Title={self.__data__[&#39;video&#39;][&#39;title&#39;]} Heartbeat={self.is_heartbeat_running}&gt;&#34;

    def log(self, type_: str, content: str, *args, **kwargs):
        &#34;&#34;&#34;:meth:`niconico.base.BaseClient.log` を使用してログ出力をします。
        出力するログに動画クラスを文字列化したものを含めます。
        開発者のための関数です。

        Parameters
        ----------
        type_ : str
            ``info`` 等
        content : str
        *args
        **kwargs&#34;&#34;&#34;
        content += &#34; (%s)&#34; % self.__str__()
        return self.client.log(type_, content, *args, **kwargs)

    @property
    def is_heartbeat_running(self) -&gt; bool:
        &#34;ハートビートが動いているかです。&#34;
        return self._heartbeat_running.is_set()

    def connect(self):
        &#34;&#34;&#34;ハートビートを動かして動画データを取得することが可能な状態にします。

        Notes
        -----
        ハートビートは定期的にニコニコ動画と通信を行うもので別スレッドで動かされます。
        動画使用後には :meth:`niconico.video.Video.close` を実行してハートビートを停止させてください。
        また、 ``with`` 構文を使用すればこの関数と :meth:`niconico.video.Video.close` を省略することができます。&#34;&#34;&#34;
        self.thread = Thread(target=self._heartbeat)
        self.thread.start()
        self._heartbeat_running.wait()
        self.client.log(&#34;info&#34;, &#34;ハートビートを開始しました。&#34;)

    def close(self):
        &#34;ハートビートを停止します。&#34;
        self.client.log(&#34;info&#34;, &#34;ハートビートを停止させました。&#34;)
        self._heartbeat_running.clear()
        self.thread.join()

    def __enter__(self):
        if not self.is_heartbeat_running:
            self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        if self.is_heartbeat_running:
            self.close()

    def _assert_heartbeat(self):
        assert self.is_heartbeat_running, &#34;ハートベートが動いていません。&#34;

    @property
    def download_link(self) -&gt; str:
        &#34;&#34;&#34;動画のダウンロードリンクを取得します。

        Notes
        -----
        これを実行する際は :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。
        また、これで取得するダウンロードリンクはハートビートが動いている状態でなければ使うことができません。

        Raises
        ------
        AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
        self._assert_heartbeat()
        return self.session[&#34;content_uri&#34;]

    def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;動画をダウンロードします。

        Parameters
        ----------
        path : str
            動画ファイルの保存先です。
        load_chunk_size : int, default 1024
            一度にダウンロードする量です。

        Notes
        -----
        これを実行する際には :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。

        Raises
        ------
        AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
        self._assert_heartbeat()
        headers = HEADERS[&#34;normal&#34;].copy()
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        # ファイルサイズを取得する。
        size = int(
            self.client.niconico.request(
                &#34;head&#34;, self.download_link, headers=headers, params=(params := (
                    (
                        &#34;ht2_nicovideo&#34;,
                        self.session[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
                    ),
                ))
            ).headers[&#34;content-length&#34;]
        )

        self.log(&#34;info&#34;, &#34;ダウンロード中...&#34;)
        r = self.client.niconico.request(
            &#34;GET&#34;, self.download_link, headers=headers, params=params, stream=True
        )

        now_size = 0
        with open(path, &#34;wb&#34;) as f:
            for chunk in r.iter_content(chunk_size=load_chunk_size):
                if chunk:
                    now_size += len(chunk)
                    f.write(chunk)
                    if self._download_log is not None:
                        self._download_log(
                            f&#34;ダウンロード済み: {int(now_size/size*100)}% ({now_size}/{size})&#34;
                        )

        self.log(&#34;info&#34;, &#34;完了&#34;)

    def _make_url(self, session_id: str) -&gt; str:
        # Heartbeat用のURLを作る。
        return f&#34;{BASES[&#39;heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;

    def _heartbeat(self):
        # ハートビート
        self.log(&#34;info&#34;, &#34;セッションIDを取得中...&#34;)
        # セッションIDを取得する。
        self.session = self.client.niconico.request(
            &#34;POST&#34;, f&#34;{BASES[&#39;heartbeat&#39;]}?_format=json&#34;,
            headers=HEADERS[&#34;heartbeat&#34;], json=self._make_session_data(
                VideoDownloadMode.http_output_download_parameters
            )
        ).json()[&#34;data&#34;][&#34;session&#34;]
        self.log(&#34;info&#34;, &#34;セッションID: %s&#34; % self.session[&#34;id&#34;])
        self._heartbeat_running.set()
        # 事前にしておかなければならないリクエストをしておく。
        self.client.niconico.request(
            &#34;OPTIONS&#34;, self._make_url(self.session[&#34;id&#34;]),
            headers=HEADERS[&#34;heartbeat_first&#34;]
        )
        # ここからは定期的に「生きているよ」のメッセージを送ります。
        after = self._get_interval(time(), {&#34;session&#34;: self.session})
        while self._heartbeat_running.is_set():
            now = time()
            if now &lt; after:
                sleep(0.05)
                continue
            data = {&#34;session&#34;: self.session}
            # 「生きているよ」リクエストをする。
            self.session = self.client.niconico.request(
                &#34;POST&#34;, self._make_url(self.session[&#34;id&#34;]),
                json=data, headers=HEADERS[&#34;heartbeat&#34;]
            ).json()[&#34;data&#34;][&#34;session&#34;]
            self.log(&#34;info&#34;, &#34;ハートビートを送信しました。&#34;)
            self.log(&#34;debug&#34;, f&#34;レスポンス: {self.session}&#34;)
            after = self._get_interval(now, data)

    def _get_interval(self, now: float, data: dict) -&gt; float:
        # ハートビートのインターバルを取得します。
        return now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3

    def _make_session_data(self, mode: VideoDownloadMode):
        # セッション用のデータを作る。
        # TODO: このセッションデータの画質設定等を解析してできればもっと細かく設定できるようにする。
        session = self.__data__[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;][&#34;session&#34;].copy()
        data: dict[Any, Any] = {}

        data[&#34;content_type&#34;] = &#34;movie&#34;
        data[&#34;content_src_id_sets&#34;] = [{&#34;content_src_ids&#34;: []}]
        data[&#34;content_src_id_sets&#34;][0][&#34;content_src_ids&#34;].append({
            &#34;src_id_to_mux&#34;: {
                &#34;video_src_ids&#34;: session[&#34;videos&#34;],
                &#34;audio_src_ids&#34;: session[&#34;audios&#34;]
            }
        })
        data[&#34;timing_constraint&#34;] = &#34;unlimited&#34;
        data[&#34;keep_method&#34;] = {
            &#34;heartbeat&#34;: {
                &#34;lifetime&#34;: session[&#34;heartbeatLifetime&#34;]
            }
        }
        data[&#34;recipe_id&#34;] = session[&#34;recipeId&#34;]
        data[&#34;priority&#34;] = session[&#34;priority&#34;]
        parameters = {
            VideoDownloadMode.http_output_download_parameters.name: {
                &#34;use_well_known_port&#34;: &#34;yes&#34; if session[&#34;urls&#34;][0][&#34;isWellKnownPort&#34;] else &#34;no&#34;,
                &#34;use_ssl&#34;: &#34;yes&#34; if session[&#34;urls&#34;][0][&#34;isSsl&#34;] else &#34;no&#34;,
                &#34;transfer_preset&#34;: &#34;&#34;
            }
        }
        data[&#34;protocol&#34;] = {
            &#34;name&#34;: &#34;http&#34;,
            &#34;parameters&#34;: {
                &#34;http_parameters&#34;: {
                    &#34;parameters&#34;: parameters
                }
            }
        }
        data[&#34;content_uri&#34;] = &#34;&#34;
        data[&#34;session_operation_auth&#34;] = {
            &#34;session_operation_auth_by_signature&#34;: {
                &#34;token&#34;: session[&#34;token&#34;],
                &#34;signature&#34;: session[&#34;signature&#34;]
            }
        }
        data[&#34;content_id&#34;] = session[&#34;contentId&#34;]
        data[&#34;content_auth&#34;] = {
            &#34;auth_type&#34;: session[&#34;authTypes&#34;][&#34;http&#34;],
            &#34;content_key_timeout&#34;: session[&#34;contentKeyTimeout&#34;],
            &#34;service_id&#34;: &#34;nicovideo&#34;,
            &#34;service_user_id&#34;: str(session[&#34;serviceUserId&#34;])
        }
        data[&#34;client_info&#34;] = {
            &#34;player_id&#34;: session[&#34;playerId&#34;]
        }
        del session

        return {&#34;session&#34;: data}
    
    def get_comments(self, fork: str, num: Optional[int] = 1000, when: Optional[int] = None) -&gt; Comments:
        &#34;&#34;&#34;動画のコメントを取得します。

        Parameters
        ----------
        fork : str
            コメントの種類です。&#34;main&#34;,&#34;owner&#34;,&#34;easy&#34;,&#34;channel&#34;が指定可能です。
        num : int, default 1000
            1度に取得する数です。1000が最大です。
        when: Optional[int]
            過去ログをUNIXタイムで指定できます。何も指定しない場合は最新のコメントを取得します。&#34;&#34;&#34;
        fork_id = &#34;0&#34;
        if fork == &#34;main&#34;:
            fork_id = &#34;0&#34;
        elif fork == &#34;owner&#34;:
            fork_id = &#34;1&#34;
        elif fork == &#34;easy&#34;:
            fork_id = &#34;2&#34;
        r = self.client.niconico.request(
            &#34;GET&#34;, f&#34;{self.comment.nvComment.server}/legacy/api.json/thread&#34;, headers=HEADERS[&#34;normal&#34;],
            params={
                &#34;fork&#34;: fork_id,
                &#34;nicoru&#34;: &#34;3&#34;,
                &#34;scores&#34;: &#34;1&#34;,
                &#34;res_from&#34;: f&#34;-{num}&#34;,
                &#34;thread&#34;: next(
                    x for x in self.comment.nvComment.params.targets if x.fork == fork).id,
                &#34;version&#34;: &#34;20090904&#34;,
                &#34;with_global&#34;: &#34;1&#34;,
                &#34;when&#34;: when or &#34;&#34;
            }
        ).json()

        comments = Comments()
        comments.fork = fork
        for obj in r:
            if &#34;thread&#34; in obj:
                if obj[&#34;thread&#34;][&#34;resultcode&#34;] == 1:
                    raise Exception(&#34;コメントの取得に失敗しました。&#34;)
                comments.thread = obj[&#34;thread&#34;][&#34;thread&#34;]
                comments.ticket = obj[&#34;thread&#34;].get(&#34;ticket&#34;)
                comments.last_res = obj[&#34;thread&#34;].get(&#34;last_res&#34;)
                comments.when = when or obj[&#34;thread&#34;][&#34;server_time&#34;]
            if &#34;leaf&#34; in obj:
                comments.count = obj[&#34;leaf&#34;][&#34;count&#34;]
            if &#34;global_num_res&#34; in obj:
                comments.num_res = obj[&#34;global_num_res&#34;][&#34;num_res&#34;]
            if &#34;chat&#34; in obj:
                comments.chats.append(MovieChat(obj[&#34;chat&#34;]))

        return comments


class Client(BaseClient):
    &#34;&#34;&#34;ニコニコ動画用のクライアントです。
    普通 :class:`niconico.niconico.NicoNico` から使います。&#34;&#34;&#34;

    def get_video(self, url: str) -&gt; Video:
        &#34;&#34;&#34;ニコニコ動画から指定された動画を取得します。

        Parameters
        ----------
        url : str
            動画のURLです。(ex. https://www.nicovideo.jp/watch/sm9)
            動画IDでも指定できます。(ex. sm9)

        Raises
        ------
        ExtractFailed&#34;&#34;&#34;
        # 短縮やスマホ用のURLであれば元に戻す。
        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)
        url = parse_link(url)

        if &#34;watch&#34; not in url:
            url = &#34;https://www.nicovideo.jp/watch/&#34; + url

        # 動画情報を取得する。
        data = BeautifulSoup(
            self.niconico.request(&#34;GET&#34;, url, headers=HEADERS[&#34;normal&#34;]).text, &#34;html.parser&#34;
        ).find(
            &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
        ).get(&#34;data-api-data&#34;)
        video = Video(self, url, data)

        if data:
            video.__data__ = loads(data)
            return video
        else:
            raise ExtractFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)

    def get_mylist(self, url: str) -&gt; Iterator[AbcMyList]:
        &#34;&#34;&#34;マイリストのデータを取得します。

        Parameters
        ----------
        url : str
            マイリストのURLです。

        Notes
        -----
        ニコニコ動画のマイリストは複数ページにわたる場合があります。  
        なので100ページずつ取得していきます。  
        よって返される各マイリストには百ページ分動画の情報が入っています。&#34;&#34;&#34;
        url = parse_link(url)
        mylist = False
        for code in url.split(&#34;/&#34;):
            if code == &#34;mylist&#34;:
                mylist = True
            elif mylist:
                self.log(&#34;info&#34;, &#34;取得中...&#34;)
                before, page = None, 0
                while before is None or before.hasNext:
                    page += 1
                    data = self.niconico.request(
                        &#34;GET&#34;, f&#34;https://nvapi.nicovideo.jp/v2/mylists/{code}&#34;,
                        headers=HEADERS[&#34;mylist&#34;], params=((&#34;pageSize&#34;, 100), (&#34;page&#34;, page))
                    ).json()
                    self.log(&#34;info&#34;, &#34;マイリストの%sページ目のデータを取得しました。&#34; % page)
                    yield (before := AbcMyList(data[&#34;data&#34;][&#34;mylist&#34;], self))
                break
        else:
            raise ValueError(&#34;URLが適切ではありません。&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="niconico.video.HEADERS"><code class="name">var <span class="ident">HEADERS</span></code></dt>
<dd>
<div class="desc"><p>リクエストに使用されるヘッダーが入っている定数です。</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="niconico.video.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>niconico: NicoNico)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画用のクライアントです。
普通 :class:<code><a title="niconico.niconico.NicoNico" href="niconico.html#niconico.niconico.NicoNico">NicoNico</a></code> から使います。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(BaseClient):
    &#34;&#34;&#34;ニコニコ動画用のクライアントです。
    普通 :class:`niconico.niconico.NicoNico` から使います。&#34;&#34;&#34;

    def get_video(self, url: str) -&gt; Video:
        &#34;&#34;&#34;ニコニコ動画から指定された動画を取得します。

        Parameters
        ----------
        url : str
            動画のURLです。(ex. https://www.nicovideo.jp/watch/sm9)
            動画IDでも指定できます。(ex. sm9)

        Raises
        ------
        ExtractFailed&#34;&#34;&#34;
        # 短縮やスマホ用のURLであれば元に戻す。
        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)
        url = parse_link(url)

        if &#34;watch&#34; not in url:
            url = &#34;https://www.nicovideo.jp/watch/&#34; + url

        # 動画情報を取得する。
        data = BeautifulSoup(
            self.niconico.request(&#34;GET&#34;, url, headers=HEADERS[&#34;normal&#34;]).text, &#34;html.parser&#34;
        ).find(
            &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
        ).get(&#34;data-api-data&#34;)
        video = Video(self, url, data)

        if data:
            video.__data__ = loads(data)
            return video
        else:
            raise ExtractFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)

    def get_mylist(self, url: str) -&gt; Iterator[AbcMyList]:
        &#34;&#34;&#34;マイリストのデータを取得します。

        Parameters
        ----------
        url : str
            マイリストのURLです。

        Notes
        -----
        ニコニコ動画のマイリストは複数ページにわたる場合があります。  
        なので100ページずつ取得していきます。  
        よって返される各マイリストには百ページ分動画の情報が入っています。&#34;&#34;&#34;
        url = parse_link(url)
        mylist = False
        for code in url.split(&#34;/&#34;):
            if code == &#34;mylist&#34;:
                mylist = True
            elif mylist:
                self.log(&#34;info&#34;, &#34;取得中...&#34;)
                before, page = None, 0
                while before is None or before.hasNext:
                    page += 1
                    data = self.niconico.request(
                        &#34;GET&#34;, f&#34;https://nvapi.nicovideo.jp/v2/mylists/{code}&#34;,
                        headers=HEADERS[&#34;mylist&#34;], params=((&#34;pageSize&#34;, 100), (&#34;page&#34;, page))
                    ).json()
                    self.log(&#34;info&#34;, &#34;マイリストの%sページ目のデータを取得しました。&#34; % page)
                    yield (before := AbcMyList(data[&#34;data&#34;][&#34;mylist&#34;], self))
                break
        else:
            raise ValueError(&#34;URLが適切ではありません。&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="niconico.base.BaseClient" href="base.html#niconico.base.BaseClient">BaseClient</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="niconico.video.Client.get_mylist"><code class="name flex">
<span>def <span class="ident">get_mylist</span></span>(<span>self, url: str) ‑> Iterator[<a title="niconico.objects.video.MyList" href="objects/video.html#niconico.objects.video.MyList">MyList</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>マイリストのデータを取得します。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>マイリストのURLです。</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>ニコニコ動画のマイリストは複数ページにわたる場合があります。<br>
なので100ページずつ取得していきます。<br>
よって返される各マイリストには百ページ分動画の情報が入っています。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mylist(self, url: str) -&gt; Iterator[AbcMyList]:
    &#34;&#34;&#34;マイリストのデータを取得します。

    Parameters
    ----------
    url : str
        マイリストのURLです。

    Notes
    -----
    ニコニコ動画のマイリストは複数ページにわたる場合があります。  
    なので100ページずつ取得していきます。  
    よって返される各マイリストには百ページ分動画の情報が入っています。&#34;&#34;&#34;
    url = parse_link(url)
    mylist = False
    for code in url.split(&#34;/&#34;):
        if code == &#34;mylist&#34;:
            mylist = True
        elif mylist:
            self.log(&#34;info&#34;, &#34;取得中...&#34;)
            before, page = None, 0
            while before is None or before.hasNext:
                page += 1
                data = self.niconico.request(
                    &#34;GET&#34;, f&#34;https://nvapi.nicovideo.jp/v2/mylists/{code}&#34;,
                    headers=HEADERS[&#34;mylist&#34;], params=((&#34;pageSize&#34;, 100), (&#34;page&#34;, page))
                ).json()
                self.log(&#34;info&#34;, &#34;マイリストの%sページ目のデータを取得しました。&#34; % page)
                yield (before := AbcMyList(data[&#34;data&#34;][&#34;mylist&#34;], self))
            break
    else:
        raise ValueError(&#34;URLが適切ではありません。&#34;)</code></pre>
</details>
</dd>
<dt id="niconico.video.Client.get_video"><code class="name flex">
<span>def <span class="ident">get_video</span></span>(<span>self, url: str) ‑> <a title="niconico.video.Video" href="#niconico.video.Video">Video</a></span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画から指定された動画を取得します。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>動画のURLです。(ex. <a href="https://www.nicovideo.jp/watch/sm9">https://www.nicovideo.jp/watch/sm9</a>)
動画IDでも指定できます。(ex. sm9)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ExtractFailed</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video(self, url: str) -&gt; Video:
    &#34;&#34;&#34;ニコニコ動画から指定された動画を取得します。

    Parameters
    ----------
    url : str
        動画のURLです。(ex. https://www.nicovideo.jp/watch/sm9)
        動画IDでも指定できます。(ex. sm9)

    Raises
    ------
    ExtractFailed&#34;&#34;&#34;
    # 短縮やスマホ用のURLであれば元に戻す。
    if &#34;nico.ms&#34; in url:
        url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)
    url = parse_link(url)

    if &#34;watch&#34; not in url:
        url = &#34;https://www.nicovideo.jp/watch/&#34; + url

    # 動画情報を取得する。
    data = BeautifulSoup(
        self.niconico.request(&#34;GET&#34;, url, headers=HEADERS[&#34;normal&#34;]).text, &#34;html.parser&#34;
    ).find(
        &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
    ).get(&#34;data-api-data&#34;)
    video = Video(self, url, data)

    if data:
        video.__data__ = loads(data)
        return video
    else:
        raise ExtractFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="niconico.base.BaseClient" href="base.html#niconico.base.BaseClient">BaseClient</a></b></code>:
<ul class="hlist">
<li><code><a title="niconico.base.BaseClient.log" href="base.html#niconico.base.BaseClient.log">log</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="niconico.video.Video"><code class="flex name class">
<span>class <span class="ident">Video</span></span>
<span>(</span><span>client: <a title="niconico.video.Client" href="#niconico.video.Client">Client</a>, url: str, data: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画のデータを含めるクラスです。
動画をダウンロードすることができます。
普通はこのクラスをインスタンスは :meth:<code><a title="niconico.video.Client.get_video" href="#niconico.video.Client.get_video">Client.get_video()</a></code> を使って作ります。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a title="niconico.video.Client" href="#niconico.video.Client">Client</a></code></dt>
<dd>動画クライアントクラスのインスタンスです。</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>取得する動画のURLです。</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>動画の辞書形式のデータです。<br>
属性からこのデータにアクセスすることができます。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Video(DictFromAttribute):
    &#34;&#34;&#34;ニコニコ動画のデータを含めるクラスです。
    動画をダウンロードすることができます。
    普通はこのクラスをインスタンスは :meth:`niconico.video.Client.get_video` を使って作ります。

    Parameters
    ----------
    client : Client
        動画クライアントクラスのインスタンスです。
    url : str
        取得する動画のURLです。
    data : dict
        動画の辞書形式のデータです。  
        属性からこのデータにアクセスすることができます。&#34;&#34;&#34;

    __dfa_class__ = DictFromAttribute

    easyComment: EasyComment
    &#34;簡易コメントデータです。&#34;
    tag: Tag
    &#34;動画についているタグです。&#34;
    video: AbcVideo
    &#34;動画のデータです。&#34;
    owner: Optional[VideoOwner]
    &#34;動画の投稿者です。&#34;
    thread: Optional[Thread] = None
    &#34;ハートビートを動かすスレッドです。&#34;
    url: str
    &#34;動画のURLです。&#34;
    client: Client
    &#34;動画取得用のクライアントのインスタンスです。&#34;
    comment: Comment
    &#34;コメントのデータです。&#34;

    def __init__(self, client: Client, url: str, data: dict):
        self.client, self.url, self.__data__ = client, url, data
        self._heartbeat_running = Event()
        self._download_log: Optional[Callable[[Any], None]] = None
        super().__init__(self.__data__, self)

    def __str__(self) -&gt; str:
        return f&#34;&lt;Video Title={self.__data__[&#39;video&#39;][&#39;title&#39;]} Heartbeat={self.is_heartbeat_running}&gt;&#34;

    def log(self, type_: str, content: str, *args, **kwargs):
        &#34;&#34;&#34;:meth:`niconico.base.BaseClient.log` を使用してログ出力をします。
        出力するログに動画クラスを文字列化したものを含めます。
        開発者のための関数です。

        Parameters
        ----------
        type_ : str
            ``info`` 等
        content : str
        *args
        **kwargs&#34;&#34;&#34;
        content += &#34; (%s)&#34; % self.__str__()
        return self.client.log(type_, content, *args, **kwargs)

    @property
    def is_heartbeat_running(self) -&gt; bool:
        &#34;ハートビートが動いているかです。&#34;
        return self._heartbeat_running.is_set()

    def connect(self):
        &#34;&#34;&#34;ハートビートを動かして動画データを取得することが可能な状態にします。

        Notes
        -----
        ハートビートは定期的にニコニコ動画と通信を行うもので別スレッドで動かされます。
        動画使用後には :meth:`niconico.video.Video.close` を実行してハートビートを停止させてください。
        また、 ``with`` 構文を使用すればこの関数と :meth:`niconico.video.Video.close` を省略することができます。&#34;&#34;&#34;
        self.thread = Thread(target=self._heartbeat)
        self.thread.start()
        self._heartbeat_running.wait()
        self.client.log(&#34;info&#34;, &#34;ハートビートを開始しました。&#34;)

    def close(self):
        &#34;ハートビートを停止します。&#34;
        self.client.log(&#34;info&#34;, &#34;ハートビートを停止させました。&#34;)
        self._heartbeat_running.clear()
        self.thread.join()

    def __enter__(self):
        if not self.is_heartbeat_running:
            self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        if self.is_heartbeat_running:
            self.close()

    def _assert_heartbeat(self):
        assert self.is_heartbeat_running, &#34;ハートベートが動いていません。&#34;

    @property
    def download_link(self) -&gt; str:
        &#34;&#34;&#34;動画のダウンロードリンクを取得します。

        Notes
        -----
        これを実行する際は :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。
        また、これで取得するダウンロードリンクはハートビートが動いている状態でなければ使うことができません。

        Raises
        ------
        AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
        self._assert_heartbeat()
        return self.session[&#34;content_uri&#34;]

    def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;動画をダウンロードします。

        Parameters
        ----------
        path : str
            動画ファイルの保存先です。
        load_chunk_size : int, default 1024
            一度にダウンロードする量です。

        Notes
        -----
        これを実行する際には :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。

        Raises
        ------
        AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
        self._assert_heartbeat()
        headers = HEADERS[&#34;normal&#34;].copy()
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        # ファイルサイズを取得する。
        size = int(
            self.client.niconico.request(
                &#34;head&#34;, self.download_link, headers=headers, params=(params := (
                    (
                        &#34;ht2_nicovideo&#34;,
                        self.session[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
                    ),
                ))
            ).headers[&#34;content-length&#34;]
        )

        self.log(&#34;info&#34;, &#34;ダウンロード中...&#34;)
        r = self.client.niconico.request(
            &#34;GET&#34;, self.download_link, headers=headers, params=params, stream=True
        )

        now_size = 0
        with open(path, &#34;wb&#34;) as f:
            for chunk in r.iter_content(chunk_size=load_chunk_size):
                if chunk:
                    now_size += len(chunk)
                    f.write(chunk)
                    if self._download_log is not None:
                        self._download_log(
                            f&#34;ダウンロード済み: {int(now_size/size*100)}% ({now_size}/{size})&#34;
                        )

        self.log(&#34;info&#34;, &#34;完了&#34;)

    def _make_url(self, session_id: str) -&gt; str:
        # Heartbeat用のURLを作る。
        return f&#34;{BASES[&#39;heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;

    def _heartbeat(self):
        # ハートビート
        self.log(&#34;info&#34;, &#34;セッションIDを取得中...&#34;)
        # セッションIDを取得する。
        self.session = self.client.niconico.request(
            &#34;POST&#34;, f&#34;{BASES[&#39;heartbeat&#39;]}?_format=json&#34;,
            headers=HEADERS[&#34;heartbeat&#34;], json=self._make_session_data(
                VideoDownloadMode.http_output_download_parameters
            )
        ).json()[&#34;data&#34;][&#34;session&#34;]
        self.log(&#34;info&#34;, &#34;セッションID: %s&#34; % self.session[&#34;id&#34;])
        self._heartbeat_running.set()
        # 事前にしておかなければならないリクエストをしておく。
        self.client.niconico.request(
            &#34;OPTIONS&#34;, self._make_url(self.session[&#34;id&#34;]),
            headers=HEADERS[&#34;heartbeat_first&#34;]
        )
        # ここからは定期的に「生きているよ」のメッセージを送ります。
        after = self._get_interval(time(), {&#34;session&#34;: self.session})
        while self._heartbeat_running.is_set():
            now = time()
            if now &lt; after:
                sleep(0.05)
                continue
            data = {&#34;session&#34;: self.session}
            # 「生きているよ」リクエストをする。
            self.session = self.client.niconico.request(
                &#34;POST&#34;, self._make_url(self.session[&#34;id&#34;]),
                json=data, headers=HEADERS[&#34;heartbeat&#34;]
            ).json()[&#34;data&#34;][&#34;session&#34;]
            self.log(&#34;info&#34;, &#34;ハートビートを送信しました。&#34;)
            self.log(&#34;debug&#34;, f&#34;レスポンス: {self.session}&#34;)
            after = self._get_interval(now, data)

    def _get_interval(self, now: float, data: dict) -&gt; float:
        # ハートビートのインターバルを取得します。
        return now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3

    def _make_session_data(self, mode: VideoDownloadMode):
        # セッション用のデータを作る。
        # TODO: このセッションデータの画質設定等を解析してできればもっと細かく設定できるようにする。
        session = self.__data__[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;][&#34;session&#34;].copy()
        data: dict[Any, Any] = {}

        data[&#34;content_type&#34;] = &#34;movie&#34;
        data[&#34;content_src_id_sets&#34;] = [{&#34;content_src_ids&#34;: []}]
        data[&#34;content_src_id_sets&#34;][0][&#34;content_src_ids&#34;].append({
            &#34;src_id_to_mux&#34;: {
                &#34;video_src_ids&#34;: session[&#34;videos&#34;],
                &#34;audio_src_ids&#34;: session[&#34;audios&#34;]
            }
        })
        data[&#34;timing_constraint&#34;] = &#34;unlimited&#34;
        data[&#34;keep_method&#34;] = {
            &#34;heartbeat&#34;: {
                &#34;lifetime&#34;: session[&#34;heartbeatLifetime&#34;]
            }
        }
        data[&#34;recipe_id&#34;] = session[&#34;recipeId&#34;]
        data[&#34;priority&#34;] = session[&#34;priority&#34;]
        parameters = {
            VideoDownloadMode.http_output_download_parameters.name: {
                &#34;use_well_known_port&#34;: &#34;yes&#34; if session[&#34;urls&#34;][0][&#34;isWellKnownPort&#34;] else &#34;no&#34;,
                &#34;use_ssl&#34;: &#34;yes&#34; if session[&#34;urls&#34;][0][&#34;isSsl&#34;] else &#34;no&#34;,
                &#34;transfer_preset&#34;: &#34;&#34;
            }
        }
        data[&#34;protocol&#34;] = {
            &#34;name&#34;: &#34;http&#34;,
            &#34;parameters&#34;: {
                &#34;http_parameters&#34;: {
                    &#34;parameters&#34;: parameters
                }
            }
        }
        data[&#34;content_uri&#34;] = &#34;&#34;
        data[&#34;session_operation_auth&#34;] = {
            &#34;session_operation_auth_by_signature&#34;: {
                &#34;token&#34;: session[&#34;token&#34;],
                &#34;signature&#34;: session[&#34;signature&#34;]
            }
        }
        data[&#34;content_id&#34;] = session[&#34;contentId&#34;]
        data[&#34;content_auth&#34;] = {
            &#34;auth_type&#34;: session[&#34;authTypes&#34;][&#34;http&#34;],
            &#34;content_key_timeout&#34;: session[&#34;contentKeyTimeout&#34;],
            &#34;service_id&#34;: &#34;nicovideo&#34;,
            &#34;service_user_id&#34;: str(session[&#34;serviceUserId&#34;])
        }
        data[&#34;client_info&#34;] = {
            &#34;player_id&#34;: session[&#34;playerId&#34;]
        }
        del session

        return {&#34;session&#34;: data}
    
    def get_comments(self, fork: str, num: Optional[int] = 1000, when: Optional[int] = None) -&gt; Comments:
        &#34;&#34;&#34;動画のコメントを取得します。

        Parameters
        ----------
        fork : str
            コメントの種類です。&#34;main&#34;,&#34;owner&#34;,&#34;easy&#34;,&#34;channel&#34;が指定可能です。
        num : int, default 1000
            1度に取得する数です。1000が最大です。
        when: Optional[int]
            過去ログをUNIXタイムで指定できます。何も指定しない場合は最新のコメントを取得します。&#34;&#34;&#34;
        fork_id = &#34;0&#34;
        if fork == &#34;main&#34;:
            fork_id = &#34;0&#34;
        elif fork == &#34;owner&#34;:
            fork_id = &#34;1&#34;
        elif fork == &#34;easy&#34;:
            fork_id = &#34;2&#34;
        r = self.client.niconico.request(
            &#34;GET&#34;, f&#34;{self.comment.nvComment.server}/legacy/api.json/thread&#34;, headers=HEADERS[&#34;normal&#34;],
            params={
                &#34;fork&#34;: fork_id,
                &#34;nicoru&#34;: &#34;3&#34;,
                &#34;scores&#34;: &#34;1&#34;,
                &#34;res_from&#34;: f&#34;-{num}&#34;,
                &#34;thread&#34;: next(
                    x for x in self.comment.nvComment.params.targets if x.fork == fork).id,
                &#34;version&#34;: &#34;20090904&#34;,
                &#34;with_global&#34;: &#34;1&#34;,
                &#34;when&#34;: when or &#34;&#34;
            }
        ).json()

        comments = Comments()
        comments.fork = fork
        for obj in r:
            if &#34;thread&#34; in obj:
                if obj[&#34;thread&#34;][&#34;resultcode&#34;] == 1:
                    raise Exception(&#34;コメントの取得に失敗しました。&#34;)
                comments.thread = obj[&#34;thread&#34;][&#34;thread&#34;]
                comments.ticket = obj[&#34;thread&#34;].get(&#34;ticket&#34;)
                comments.last_res = obj[&#34;thread&#34;].get(&#34;last_res&#34;)
                comments.when = when or obj[&#34;thread&#34;][&#34;server_time&#34;]
            if &#34;leaf&#34; in obj:
                comments.count = obj[&#34;leaf&#34;][&#34;count&#34;]
            if &#34;global_num_res&#34; in obj:
                comments.num_res = obj[&#34;global_num_res&#34;][&#34;num_res&#34;]
            if &#34;chat&#34; in obj:
                comments.chats.append(MovieChat(obj[&#34;chat&#34;]))

        return comments</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="niconico.base.DictFromAttribute" href="base.html#niconico.base.DictFromAttribute">DictFromAttribute</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="niconico.video.Video.client"><code class="name">var <span class="ident">client</span> : <a title="niconico.video.Client" href="#niconico.video.Client">Client</a></code></dt>
<dd>
<div class="desc"><p>動画取得用のクライアントのインスタンスです。</p></div>
</dd>
<dt id="niconico.video.Video.comment"><code class="name">var <span class="ident">comment</span> : <a title="niconico.objects.video.Comment" href="objects/video.html#niconico.objects.video.Comment">Comment</a></code></dt>
<dd>
<div class="desc"><p>コメントのデータです。</p></div>
</dd>
<dt id="niconico.video.Video.easyComment"><code class="name">var <span class="ident">easyComment</span> : <a title="niconico.objects.video.EasyComment" href="objects/video.html#niconico.objects.video.EasyComment">EasyComment</a></code></dt>
<dd>
<div class="desc"><p>簡易コメントデータです。</p></div>
</dd>
<dt id="niconico.video.Video.owner"><code class="name">var <span class="ident">owner</span> : Optional[<a title="niconico.objects.video.VideoOwner" href="objects/video.html#niconico.objects.video.VideoOwner">VideoOwner</a>]</code></dt>
<dd>
<div class="desc"><p>動画の投稿者です。</p></div>
</dd>
<dt id="niconico.video.Video.tag"><code class="name">var <span class="ident">tag</span> : <a title="niconico.objects.video.Tag" href="objects/video.html#niconico.objects.video.Tag">Tag</a></code></dt>
<dd>
<div class="desc"><p>動画についているタグです。</p></div>
</dd>
<dt id="niconico.video.Video.thread"><code class="name">var <span class="ident">thread</span> : Optional[threading.Thread]</code></dt>
<dd>
<div class="desc"><p>ハートビートを動かすスレッドです。</p></div>
</dd>
<dt id="niconico.video.Video.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>動画のURLです。</p></div>
</dd>
<dt id="niconico.video.Video.video"><code class="name">var <span class="ident">video</span> : <a title="niconico.objects.video.Video" href="objects/video.html#niconico.objects.video.Video">Video</a></code></dt>
<dd>
<div class="desc"><p>動画のデータです。</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="niconico.video.Video.download_link"><code class="name">var <span class="ident">download_link</span> : str</code></dt>
<dd>
<div class="desc"><p>動画のダウンロードリンクを取得します。</p>
<h2 id="notes">Notes</h2>
<p>これを実行する際は :meth:<code><a title="niconico.video.Video.connect" href="#niconico.video.Video.connect">Video.connect()</a></code> でハートビートを動かす必要があります。
また、これで取得するダウンロードリンクはハートビートが動いている状態でなければ使うことができません。</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>AssertionError</code></strong> :&ensp;<code>ハートビートが動いていない際に発生します。</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def download_link(self) -&gt; str:
    &#34;&#34;&#34;動画のダウンロードリンクを取得します。

    Notes
    -----
    これを実行する際は :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。
    また、これで取得するダウンロードリンクはハートビートが動いている状態でなければ使うことができません。

    Raises
    ------
    AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
    self._assert_heartbeat()
    return self.session[&#34;content_uri&#34;]</code></pre>
</details>
</dd>
<dt id="niconico.video.Video.is_heartbeat_running"><code class="name">var <span class="ident">is_heartbeat_running</span> : bool</code></dt>
<dd>
<div class="desc"><p>ハートビートが動いているかです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_heartbeat_running(self) -&gt; bool:
    &#34;ハートビートが動いているかです。&#34;
    return self._heartbeat_running.is_set()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="niconico.video.Video.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ハートビートを停止します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;ハートビートを停止します。&#34;
    self.client.log(&#34;info&#34;, &#34;ハートビートを停止させました。&#34;)
    self._heartbeat_running.clear()
    self.thread.join()</code></pre>
</details>
</dd>
<dt id="niconico.video.Video.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ハートビートを動かして動画データを取得することが可能な状態にします。</p>
<h2 id="notes">Notes</h2>
<p>ハートビートは定期的にニコニコ動画と通信を行うもので別スレッドで動かされます。
動画使用後には :meth:<code><a title="niconico.video.Video.close" href="#niconico.video.Video.close">Video.close()</a></code> を実行してハートビートを停止させてください。
また、 <code>with</code> 構文を使用すればこの関数と :meth:<code><a title="niconico.video.Video.close" href="#niconico.video.Video.close">Video.close()</a></code> を省略することができます。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;ハートビートを動かして動画データを取得することが可能な状態にします。

    Notes
    -----
    ハートビートは定期的にニコニコ動画と通信を行うもので別スレッドで動かされます。
    動画使用後には :meth:`niconico.video.Video.close` を実行してハートビートを停止させてください。
    また、 ``with`` 構文を使用すればこの関数と :meth:`niconico.video.Video.close` を省略することができます。&#34;&#34;&#34;
    self.thread = Thread(target=self._heartbeat)
    self.thread.start()
    self._heartbeat_running.wait()
    self.client.log(&#34;info&#34;, &#34;ハートビートを開始しました。&#34;)</code></pre>
</details>
</dd>
<dt id="niconico.video.Video.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, path: str, load_chunk_size: int = 1024) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>動画をダウンロードします。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>動画ファイルの保存先です。</dd>
<dt><strong><code>load_chunk_size</code></strong> :&ensp;<code>int</code>, default <code>1024</code></dt>
<dd>一度にダウンロードする量です。</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>これを実行する際には :meth:<code><a title="niconico.video.Video.connect" href="#niconico.video.Video.connect">Video.connect()</a></code> でハートビートを動かす必要があります。</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>AssertionError</code></strong> :&ensp;<code>ハートビートが動いていない際に発生します。</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
    &#34;&#34;&#34;動画をダウンロードします。

    Parameters
    ----------
    path : str
        動画ファイルの保存先です。
    load_chunk_size : int, default 1024
        一度にダウンロードする量です。

    Notes
    -----
    これを実行する際には :meth:`niconico.video.Video.connect` でハートビートを動かす必要があります。

    Raises
    ------
    AssertionError : ハートビートが動いていない際に発生します。&#34;&#34;&#34;
    self._assert_heartbeat()
    headers = HEADERS[&#34;normal&#34;].copy()
    headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

    # ファイルサイズを取得する。
    size = int(
        self.client.niconico.request(
            &#34;head&#34;, self.download_link, headers=headers, params=(params := (
                (
                    &#34;ht2_nicovideo&#34;,
                    self.session[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
                ),
            ))
        ).headers[&#34;content-length&#34;]
    )

    self.log(&#34;info&#34;, &#34;ダウンロード中...&#34;)
    r = self.client.niconico.request(
        &#34;GET&#34;, self.download_link, headers=headers, params=params, stream=True
    )

    now_size = 0
    with open(path, &#34;wb&#34;) as f:
        for chunk in r.iter_content(chunk_size=load_chunk_size):
            if chunk:
                now_size += len(chunk)
                f.write(chunk)
                if self._download_log is not None:
                    self._download_log(
                        f&#34;ダウンロード済み: {int(now_size/size*100)}% ({now_size}/{size})&#34;
                    )

    self.log(&#34;info&#34;, &#34;完了&#34;)</code></pre>
</details>
</dd>
<dt id="niconico.video.Video.get_comments"><code class="name flex">
<span>def <span class="ident">get_comments</span></span>(<span>self, fork: str, num: Optional[int] = 1000, when: Optional[int] = None) ‑> <a title="niconico.objects.comment.Comments" href="objects/comment.html#niconico.objects.comment.Comments">Comments</a></span>
</code></dt>
<dd>
<div class="desc"><p>動画のコメントを取得します。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fork</code></strong> :&ensp;<code>str</code></dt>
<dd>コメントの種類です。"main","owner","easy","channel"が指定可能です。</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code>, default <code>1000</code></dt>
<dd>1度に取得する数です。1000が最大です。</dd>
<dt><strong><code>when</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>過去ログをUNIXタイムで指定できます。何も指定しない場合は最新のコメントを取得します。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_comments(self, fork: str, num: Optional[int] = 1000, when: Optional[int] = None) -&gt; Comments:
    &#34;&#34;&#34;動画のコメントを取得します。

    Parameters
    ----------
    fork : str
        コメントの種類です。&#34;main&#34;,&#34;owner&#34;,&#34;easy&#34;,&#34;channel&#34;が指定可能です。
    num : int, default 1000
        1度に取得する数です。1000が最大です。
    when: Optional[int]
        過去ログをUNIXタイムで指定できます。何も指定しない場合は最新のコメントを取得します。&#34;&#34;&#34;
    fork_id = &#34;0&#34;
    if fork == &#34;main&#34;:
        fork_id = &#34;0&#34;
    elif fork == &#34;owner&#34;:
        fork_id = &#34;1&#34;
    elif fork == &#34;easy&#34;:
        fork_id = &#34;2&#34;
    r = self.client.niconico.request(
        &#34;GET&#34;, f&#34;{self.comment.nvComment.server}/legacy/api.json/thread&#34;, headers=HEADERS[&#34;normal&#34;],
        params={
            &#34;fork&#34;: fork_id,
            &#34;nicoru&#34;: &#34;3&#34;,
            &#34;scores&#34;: &#34;1&#34;,
            &#34;res_from&#34;: f&#34;-{num}&#34;,
            &#34;thread&#34;: next(
                x for x in self.comment.nvComment.params.targets if x.fork == fork).id,
            &#34;version&#34;: &#34;20090904&#34;,
            &#34;with_global&#34;: &#34;1&#34;,
            &#34;when&#34;: when or &#34;&#34;
        }
    ).json()

    comments = Comments()
    comments.fork = fork
    for obj in r:
        if &#34;thread&#34; in obj:
            if obj[&#34;thread&#34;][&#34;resultcode&#34;] == 1:
                raise Exception(&#34;コメントの取得に失敗しました。&#34;)
            comments.thread = obj[&#34;thread&#34;][&#34;thread&#34;]
            comments.ticket = obj[&#34;thread&#34;].get(&#34;ticket&#34;)
            comments.last_res = obj[&#34;thread&#34;].get(&#34;last_res&#34;)
            comments.when = when or obj[&#34;thread&#34;][&#34;server_time&#34;]
        if &#34;leaf&#34; in obj:
            comments.count = obj[&#34;leaf&#34;][&#34;count&#34;]
        if &#34;global_num_res&#34; in obj:
            comments.num_res = obj[&#34;global_num_res&#34;][&#34;num_res&#34;]
        if &#34;chat&#34; in obj:
            comments.chats.append(MovieChat(obj[&#34;chat&#34;]))

    return comments</code></pre>
</details>
</dd>
<dt id="niconico.video.Video.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, type_: str, content: str, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:meth:<code><a title="niconico.base.BaseClient.log" href="base.html#niconico.base.BaseClient.log">BaseClient.log()</a></code> を使用してログ出力をします。
出力するログに動画クラスを文字列化したものを含めます。
開発者のための関数です。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_</code></strong> :&ensp;<code>str</code></dt>
<dd><code>info</code> 等</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, type_: str, content: str, *args, **kwargs):
    &#34;&#34;&#34;:meth:`niconico.base.BaseClient.log` を使用してログ出力をします。
    出力するログに動画クラスを文字列化したものを含めます。
    開発者のための関数です。

    Parameters
    ----------
    type_ : str
        ``info`` 等
    content : str
    *args
    **kwargs&#34;&#34;&#34;
    content += &#34; (%s)&#34; % self.__str__()
    return self.client.log(type_, content, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="docs Home" href="https://niconicolibs.github.io/niconico.py/">
<img src="https://avatars.githubusercontent.com/u/113749892?s=512" alt=""> niconico.py
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="niconico" href="index.html">niconico</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="niconico.video.HEADERS" href="#niconico.video.HEADERS">HEADERS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="niconico.video.Client" href="#niconico.video.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="niconico.video.Client.get_mylist" href="#niconico.video.Client.get_mylist">get_mylist</a></code></li>
<li><code><a title="niconico.video.Client.get_video" href="#niconico.video.Client.get_video">get_video</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="niconico.video.Video" href="#niconico.video.Video">Video</a></code></h4>
<ul class="">
<li><code><a title="niconico.video.Video.client" href="#niconico.video.Video.client">client</a></code></li>
<li><code><a title="niconico.video.Video.close" href="#niconico.video.Video.close">close</a></code></li>
<li><code><a title="niconico.video.Video.comment" href="#niconico.video.Video.comment">comment</a></code></li>
<li><code><a title="niconico.video.Video.connect" href="#niconico.video.Video.connect">connect</a></code></li>
<li><code><a title="niconico.video.Video.download" href="#niconico.video.Video.download">download</a></code></li>
<li><code><a title="niconico.video.Video.download_link" href="#niconico.video.Video.download_link">download_link</a></code></li>
<li><code><a title="niconico.video.Video.easyComment" href="#niconico.video.Video.easyComment">easyComment</a></code></li>
<li><code><a title="niconico.video.Video.get_comments" href="#niconico.video.Video.get_comments">get_comments</a></code></li>
<li><code><a title="niconico.video.Video.is_heartbeat_running" href="#niconico.video.Video.is_heartbeat_running">is_heartbeat_running</a></code></li>
<li><code><a title="niconico.video.Video.log" href="#niconico.video.Video.log">log</a></code></li>
<li><code><a title="niconico.video.Video.owner" href="#niconico.video.Video.owner">owner</a></code></li>
<li><code><a title="niconico.video.Video.tag" href="#niconico.video.Video.tag">tag</a></code></li>
<li><code><a title="niconico.video.Video.thread" href="#niconico.video.Video.thread">thread</a></code></li>
<li><code><a title="niconico.video.Video.url" href="#niconico.video.Video.url">url</a></code></li>
<li><code><a title="niconico.video.Video.video" href="#niconico.video.Video.video">video</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>